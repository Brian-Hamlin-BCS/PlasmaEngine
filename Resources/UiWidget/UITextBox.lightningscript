// MIT Licensed (see LICENSE.md).
class UITextBox : LightningComponent
{
  [Dependency] var MouseCapture : MouseCapture;
  
  [Dependency] var UIWidget : UiWidget;
  
  [Property]
  var SpriteText: Archetype = Archetype.UiSpriteText;
  
  [Property]
  var Line : Archetype = Archetype.UiLineSprite;
  
  [Property]
  var Selection : Archetype = Archetype.UiSelectionSprite;
  
  [Property]
  var Caret : Archetype = Archetype.UiCaret;
  
  [Property]
  var MinLineHeight : Real = 10.0;
  
  [Property]
  var NewLineMarkerWidth : Real = 10.0;
  
  var Characters : Integer;
  
  var Lines = Array[UILine]();
  var Carets = Array[UICaret]();
  
  var Selections = Array[UISelection]();
  
  
  var CurrentSelection : UISelection; 
  
  function Initialize(init : CogInitializer)
  {
    this.AddLine();
    this.AddTextElement("This is a test of the new text box! It supports inline objects ");
    this.AddTextElement(" and ");
    this.AddTextElement("colored").UiWidget.LocalColor = Colors.Red;
    this.AddTextElement(" text!");
    this.AddLine();
    this.AddTextElement("It also supports ");
    this.AddTextElement("multiple lines").UiWidget.LocalColor = Colors.Green;
    this.AddTextElement(" as well as ");
    this.AddTextElement("bolding").SpriteText.Font = Font.FindOrError("NotoSans-Bold");
    
    Plasma.Connect(this.Owner, Events.TransformUpdated, this.OnTransformUpdate);
    Plasma.Connect(this.Owner, Events.MouseDown, this.OnMouseDown);
    Plasma.Connect(this.Owner, Events.MouseMove, this.OnMouseMove);
    Plasma.Connect(this.Owner, Events.MouseUp, this.OnMouseUp);
    Plasma.Connect(this.Owner, Events.KeyDown, this.OnKeyDown);
    Plasma.Connect(this.Owner, Events.TextTyped, this.OnTextTyped);
  }
  
   function OnKeyDown(event : KeyboardEvent)
  {
    if (event.Key == Keys.Back)
    {
      this.EraseText(-1);
    }
    else if (event.Key == Keys.Delete)
    {
      this.EraseText(+1);
    }
    else if (event.Key == Keys.Left)
    {
      this.MoveSelections(-1, event.ShiftPressed, true);
    }
    else if (event.Key == Keys.Right)
    {
      this.MoveSelections(+1, event.ShiftPressed, true);
    }
  }

  function OnTextTyped(event : KeyboardTextEvent)
  {
    if (this.Space.MarkedForDestruction)
      return;
    
    // It must be a printable ascii character
    if (event.Rune.Value < 32)
      return;
    
    this.InsertText("`event.Rune`");
  }

  function OnMouseDown(event : ViewportMouseEvent)
  {
    //this.MouseCapture.Capture(event);
    
    // This should never need to happen if we're using a mouse capture
    this.ClearCurrentSelection();
    
    if (!event.CtrlPressed)
      this.ClearSelections();
    
    var uiCaret = this.GetCaret(event.HitPosition, event.HitObject.UiWidget);
    
    this.CurrentSelection = UISelection();
    var selection = this.CurrentSelection;
    selection.SetAllIndices(uiCaret.Index);
    selection.Caret = this.Create(this.Caret);
    selection.Caret.UiWidget.Interactive = false;
    this.UpdateSelection(selection);
    
    //
    ////Console.WriteLine(caret.Index);
    //
    ////var uiCaret = this.GetCaretPosition(caret.Index);
    //
    //var cursor = this.Space.FindObjectByName("Cursor");
    //cursor.Transform.WorldTranslation = uiCaret.WorldPosition;
    //cursor.Area.Size = Real2(1, uiCaret.UiLine.LocalContainingRect.SizeY);
  }
  
  
  function UpdateMouse(event : ViewportMouseEvent) : UICaret
  {
    if (this.CurrentSelection == null)
      return null;
    
    var uiCaret = this.GetCaret(event.HitPosition, event.HitObject.UiWidget);
    if (uiCaret != null)
    {
      var selection = this.CurrentSelection;
      selection.Hover = uiCaret.Index; 
      selection.Range.SetInOrder(selection.Anchor, selection.Hover);
      this.UpdateSelection(selection);
    }
    return uiCaret;
  }
  
  function OnMouseMove(event : ViewportMouseEvent)
  {
    this.UpdateMouse(event);
  }
  
  function OnMouseUp(event : ViewportMouseEvent)
  {
    var uiCaret = this.UpdateMouse(event);
    
    if (uiCaret != null)
    {
      this.AddSelection(this.CurrentSelection);
      this.CurrentSelection = null;
    }
    else
    {
      this.ClearCurrentSelection();
    }
  }
  
  function ClearCurrentSelection()
  {
    if (this.CurrentSelection != null)
      this.CurrentSelection.Clear();
    this.CurrentSelection = null;
  }
  
  // Move the selections (HOVER, not START/END) and then call MergeSelections then UpdateSelections, or just make the user call UpdateAllSelections
  function MoveSelections(offset : Integer, modify : Boolean, updateSelections : Boolean)
  {
    foreach (var selection in this.Selections)
    {
      if (modify)
      {
        selection.Hover = Math.Clamp(offset + selection.Hover, 0, this.Carets.LastIndex);
        selection.Range.SetInOrder(selection.Anchor, selection.Hover);
      }
      else
      {
        if (selection.IsEmpty)
        {
          if (offset < 0)
            selection.SetAllIndices(Math.Max(selection.Range.Start + offset, 0));
          else
            selection.SetAllIndices(Math.Min(selection.Range.End + offset, this.Carets.LastIndex));
        }
        else
        {
          if (offset < 0)
            selection.SetAllIndices(selection.Range.Start);
          else
            selection.SetAllIndices(selection.Range.End);
        }
      }
    }
    
    this.MergeSelections(offset);
    if (updateSelections)
      this.UpdateAllSelections();
  }
  
  function UpdateAllSelections()
  {
    foreach (var selection in this.Selections)
      this.UpdateSelection(selection);
  }
  
  function EraseText(offsetIfEmpty : Integer)
  {
    if (offsetIfEmpty != 0)
    {
      var allEmpty = true;
      foreach (var selection in this.Selections)
      {
        if (!selection.Range.IsEmpty)
        {
          allEmpty = false;
          break;
        }
      }
      
      if (allEmpty)
      {
        this.MoveSelections(offsetIfEmpty, true, false);
      }
    }
    
    // Walk the selections backwards so we don't need to update indices as we erase
    for (var s = this.Selections.Count - 1; s >= 0; --s)
    {
      var selection = this.Selections[s];
      
      for (var i = selection.Range.End - 1; i >= selection.Range.Start; 0)
      {
        var caret = this.GetCaret(i);
        
        var uiElement = caret.UIElement;
        if (uiElement != null && !uiElement.Owner.MarkedForDestruction)
        {
          i = uiElement.Range.Start - 1;
          
          if (uiElement.Owner.Archetype == Archetype.UiNewLine && uiElement.Index == uiElement.Line.Elements.LastIndex)
          {
            // We must ALWAYS have a next line because we should block all cases to delete the last newline in the file
            var thisUiLine = uiElement.Line;
            var nextUiLine = this.Lines[thisUiLine.Index + 1];
            this.Lines.RemoveAt(nextUiLine.Index);
            
            foreach (var nextUiElement in nextUiLine.Elements)
            {
              thisUiLine.Elements.Add(nextUiElement);
              nextUiElement.Owner.AttachTo(thisUiLine.Owner);
            }
            nextUiLine.Owner.Destroy();
            nextUiLine.Elements.Clear();
          }
          
          if (selection.Range.Contains(uiElement.Range))
          {
            caret.UILine.Elements.RemoveAt(uiElement.Index);
            uiElement.Owner.Destroy();
          }
          else
          {
            var spriteText = uiElement.Owner.SpriteText;
            if (spriteText != null)
            {
              var intersection = selection.Range.Intersection(uiElement.Range);
              intersection.Start -= uiElement.Range.Start;
              intersection.End -= uiElement.Range.Start;
              
              var first = UIRange(0, intersection.Start);
              var second = UIRange(intersection.End, spriteText.Text.ComputeRuneCount());
              
              var firstText = spriteText.Text.SubStringFromRuneIndices(first.Start, first.End);
              var secondText = spriteText.Text.SubStringFromRuneIndices(second.Start, second.End);
              spriteText.Text = "`firstText``secondText`";
            }
            else
            {
              Console.WriteLine("The only element that may be more than one character long is a SpriteText");
            }
          }
        }
        else
        {
          // Walk back by one character
          --i;
        }
      }
      
      var count = selection.Range.Count;
      
      for (var j = s + 1; j < this.Selections.Count; ++j)
      {
        var selectionAfter = this.Selections[j];
        selectionAfter.Anchor -= count;
        selectionAfter.Hover -= count;
        selectionAfter.Range.Start -= count;
        selectionAfter.Range.End -= count;
      }
      
      selection.SetAllIndices(selection.Range.Start);
    }
    
    this.ComputeLayout();
    this.UpdateAllSelections();
  }
  
  function InsertText(text : String)
  {
    this.EraseText(0);
    
    var length = text.ComputeRuneCount();
    
    // All selections should be single carats by now (empty)
    // Walk backwards so we can insert without having to update every selection
    for (var i = this.Selections.Count - 1; i >= 0; --i)
    {
      var selection = this.Selections[i];
      var caret = this.GetCaret(selection.Range.End);
      
      // Refactor this to use the same create logic below
      var element = this.Create(this.SpriteText, caret.UILine.Owner);
      element.AddComponentByType(typeid(UIElement));
      element.UIElement.Index = caret.UILine.Elements.Count;
      
      element.SpriteText.Text = text;
      caret.UILine.Elements.Insert(caret.UIElement.Index, element.UIElement);
      
      for (var j = i; j < this.Selections.Count; ++j)
      {
        var selectionAfter = this.Selections[j];
        selectionAfter.SetAllIndices(selectionAfter.Range.End + length);
      }
    }
    
    this.ComputeLayout();
    this.UpdateAllSelections();
  }
  
  function ClearSelections()
  {
    foreach (var selection in this.Selections)
    {
      selection.Clear();
    }
    
    this.Selections.Clear();
  }
  
  function MergeSelections(direction : Integer) : Boolean
  {
    var wasMerged = false;
    
    for (var i = 0; i < this.Selections.Count - 1; 0)
    {
      var a = this.Selections[i];
      var b = this.Selections[i + 1];
      
      if (a.Range.Overlaps(b.Range))
      {
        this.Selections.RemoveAt(i + 1);
        
        a.Range.Start = Math.Min(a.Range.Start, b.Range.Start);
        a.Range.End = Math.Max(a.Range.End, b.Range.End);
        
        if (direction >= 0)
        {
          a.Anchor = a.Range.Start;
          a.Hover = a.Range.End;
        }
        else
        {
          a.Anchor = a.Range.End;
          a.Hover = a.Range.Start;
        }
        
        b.Clear();
        wasMerged = true;
      }
      else
      {
        ++i;
      }
    }
    
    return wasMerged;
  }
  
  function AddSelection(selection : UISelection)
  {
    // This could be optimized to be an insertion sort
    this.Selections.Add(selection);
    this.Selections.Sort(UISelection.Less);
    
    if (this.MergeSelections(Math.Sign(selection.Hover - selection.Anchor)))
      this.UpdateAllSelections();
  }

  var Updated : Boolean = false;
  function OnTransformUpdate(event : ObjectEvent)
  {
    if (this.Updated)
      return;
    
    this.Updated = true;
    this.ComputeLayout();
  }
  
  function GetCaret(positionWorld : Real3) : UICaret
  {
    var castResult = this.UIWidget.CastPoint(positionWorld.XY, null, true);
    return this.GetCaret(positionWorld, castResult);
  }
  
  function GetCaret(positionWorld : Real3, child : UiWidget) : UICaret
  {
    var result = UICaret();
    
    var line : UILine = null;
    var element : UIElement = null;
    
    while (child != null)
    {
      element = child.Owner.UIElement;
      if (element != null)
      {
        line = element.Owner.Parent.UILine;
        break;
      }
      
      line = child.Owner.UILine;
      if (line != null)
      {
        break;
      }
      
      child = child.Parent;
    }
    
    if (line == null)
    {
      if (this.Lines.Count != 0)
      {
        var lastLine = this.Lines[this.Lines.LastIndex];
        
        // Use the last position of the last line
        result.Index = this.Characters - 1;
        result.UILine = lastLine;
        
        // We always have the dummy new-line at the end
        result.UIElement = lastLine.Elements[lastLine.Elements.LastIndex];
        result.WorldPosition = result.UIElement.Owner.UiWidget.WorldTranslation;
      }
      return result;
    }
    
    result.UIElement = element;
    result.UILine = line;
    
    if (element != null)
    {
      result.Index = element.Range.Start;
      
      var spriteText = element.Owner.SpriteText;
      if (spriteText != null)
      {
        var screenPos = this.UIWidget.TransformPoint(positionWorld.XY);
        
        var characterIndex = spriteText.GetCharacterIndex(screenPos.X);
        result.Index += characterIndex;
        result.WorldPosition = spriteText.GetCharacterPosition(characterIndex).XY;
        return result;
      }
      else
      {
        var localPosition = element.Owner.Transform.TransformPointInverse(positionWorld);
        var hitSize = element.Owner.Area.Size;
        
        var worldRect =  element.Owner.UiWidget.WorldRectangle;
        
        if (localPosition.X < hitSize.X / 2.0)
        {
          result.WorldPosition = worldRect.TopLeft; 
          return result;
        }
        else
        {
          result.WorldPosition = worldRect.TopRight;
          ++result.Index;
          return result;
        }
      }
    } 
    else
    {
      // Point at the fake newline character
      var lastElement = line.Elements[line.Elements.LastIndex];
      result.UIElement = lastElement;
      result.Index = lastElement.Range.Start;
      result.WorldPosition = lastElement.Owner.UiWidget.WorldTranslation;
    }
    
    return result;
  }
  
  function GetCaret(index : Integer) : UICaret
  {
    return this.Carets[index];
  }
  
  function UpdateSelection(selection : UISelection)
  {
    // Update the cursor location
    var hoverCaret = this.GetCaret(selection.Hover);
    
    var selectionCaretWidget = selection.Caret.UiWidget;
    selectionCaretWidget.Size = Real2(selectionCaretWidget.Size.X, hoverCaret.UILine.Owner.UiWidget.Size.Y);
    selectionCaretWidget.Owner.Transform.WorldTranslation = Real3(hoverCaret.WorldPosition, 0);// what?
    
    selection.ClearSelectionsPerLine();
    
    var selectionCogs = selection.SelectionsPerLine;
    var cursorStart = this.GetCaret(selection.Range.Start);
    var cursorEnd = this.GetCaret(selection.Range.End);
    
    var startLine = cursorStart.UILine.Index;
    var endLine = cursorEnd.UILine.Index;
    
    for (var i = startLine; i <= endLine; ++i)
    {
      var uiLine = this.Lines[i];
      var selectionCog = this.Create(this.Selection);
      selectionCogs.Add(selectionCog);
      selectionCog.Name = "Selection";
      var selectionWidget = selectionCog.UiWidget;
      selectionWidget.Interactive = false;
      
      var uiLineWidget = uiLine.Owner.UiWidget;
      
      var startPosWorld = uiLineWidget.TransformPointInverse(Real2(0, 0));
      var endPosWorld =  uiLineWidget.TransformPointInverse(Real2(uiLine.Width, 0));
      
      if (i == startLine)
        startPosWorld = cursorStart.WorldPosition.XY;
      
      if (i == endLine)
        endPosWorld = cursorEnd.WorldPosition.XY;
      
      selectionWidget.Size = Real2(endPosWorld.X - startPosWorld.X, uiLine.Owner.UiWidget.Size.Y);
      selectionWidget.WorldTranslation = startPosWorld;
    }
  }
  
  function ComputeLayout()
  {
    var sizeX = this.UIWidget.Size.X;
    var caretIndex = 0;
    
    var linePosWorld = this.UIWidget.WorldRectangle.TopLeft;
    var lineIndex = 0;
    
    this.Carets.Clear();
    
    foreach (var uiLine in this.Lines)
    {
      var lineHeight = this.MinLineHeight;
      
      // Set all element sizes to match the line height
      foreach (var uiElement in uiLine.Elements)
      {
        var area = uiElement.Owner.Area;
        var spriteText = uiElement.Owner.SpriteText;
        if (spriteText != null)
          area.Size = spriteText.MeasureGivenText(spriteText.Text);
        
        lineHeight = Math.Max(lineHeight, area.Size.Y);
      }
      
      linePosWorld.Y -= lineHeight;
      
      var line = uiLine.Owner;
      var lineWidget = line.UiWidget;
      lineWidget.Owner.Transform.WorldTranslation = Real3(linePosWorld, 0); // what?
      lineWidget.Size = Real2(sizeX, lineHeight);
      
      var elementXUi = 0.0;
      
      uiLine.Range.Start = caretIndex;
      uiLine.Index = lineIndex;
      
      var elementIndex = 0;
      
      foreach (var uiElement in uiLine.Elements)
      {
        uiElement.Index = elementIndex;
        uiElement.Line = uiLine;
        
        var caretLength = 1;
        
        var element = uiElement.Owner;
        element.UiWidget.LocalTranslation = Real2(elementXUi, 0);
        
        var area = element.Area;
        var spriteText = element.SpriteText;
        if (spriteText != null)
        {
          caretLength = spriteText.Text.ComputeRuneCount();
                    
          for (var i = 0; i < caretLength; ++i)
          {
            this.Carets.Add(UICaret()
            {
              Index = caretIndex + i,
              WorldPosition = Real2(spriteText.GetCharacterIndex(i).X, linePosWorld.Y),
              UILine = uiLine,
              UIElement = uiElement,
            });
          }
        }
        else
        {
          this.Carets.Add(UICaret()
          {
            Index = caretIndex,
            WorldPosition = element.UiWidget.WorldTranslation,
            UILine = uiLine,
            UIElement = uiElement,
          });
        }
        
        uiElement.Range.Start = caretIndex;
        caretIndex += caretLength;
        uiElement.Range.End = caretIndex;
        
        var size = area.Size;
        elementXUi += size.X;
        ++elementIndex;
      }
      
      // Set all element sizes to match the line height
      foreach (var uiElement in uiLine.Elements)
      {
        var area = uiElement.Owner.Area;
        area.Size = Real2(area.Size.X, lineHeight);
      }
      
      uiLine.Width = elementXUi;
      uiLine.Range.End = caretIndex;
      
      ++lineIndex;
    }
    
    
    this.Characters = caretIndex;
  }
  
  function Create(archetype : Archetype) : Cog
  {
    return this.Create(archetype, this.Owner);
  }
  
  function Create(archetype : Archetype, parent : Cog) : Cog
  {
    var cog = this.Space.Create(archetype);
    if (parent != null)
      cog.AttachTo(parent);
    cog.Transient = true;
    cog.Transform.Reset();
    return cog;
  }
  
  function AddLine()
  {
    var cog = this.Create(this.Line);
    cog.AddComponentByType(typeid(UILine));
    this.Lines.Add(cog.UILine); 
    
    // Create the psuedo 'new-line' character
    this.AddElement(Archetype.UiNewLine).Area.Size = Real2(this.NewLineMarkerWidth, 1);
  }
  
  function AddElement(element : Cog) : Cog
  {
    var lastLine = this.Lines[this.Lines.LastIndex];
    element.AttachTo(lastLine.Owner);
    element.AddComponentByType(typeid(UIElement));
    element.UIElement.Index = lastLine.Elements.Count;
    
    if (lastLine.Elements.Count == 0)
      lastLine.Elements.Add(element.UIElement);
    else
      lastLine.Elements.Insert(lastLine.Elements.LastIndex, element.UIElement);
    return element;
  }
  
  function AddElement(archetype : Archetype) : Cog
  {
    var cog = this.Create(archetype, null);
    return this.AddElement(cog);
  }
  
  function AddTextElement(text : String) : Cog
  {
    var cog = this.AddElement(this.SpriteText);
    cog.SpriteText.Text = text;
    return cog;
  }
  
  function AddTextElement() : Cog
  {
    return this.AddTextElement("");
  }
}