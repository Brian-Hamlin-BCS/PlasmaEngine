// MIT Licensed (see LICENSE.md).

// Data required to run indirect lighting calculations.
struct ImageBasedLightingInputs
{
  var WorldNormal : Real3;
  var WorldViewDirection : Real3;
  
  var Albedo : Real3;
  var Metallic : Real;
  var Roughness : Real;
  var Specular : Real;
  
  var SSR : Real4;
  
  var RenderDiffuse : Boolean;
  var RenderSpecular : Boolean;
}

// Indirect lighting using an image (skybox).
// The texture used for the skybox must use PreGenerated mip mapping for correct results,
// which stores pre-computed integrals in the mip levels for the purpose of lighting.
[Pixel][PostProcess]
struct ImageBasedLighting
{
  [AppBuiltInInput] var PerspectiveToView : Real4x4;
  [AppBuiltInInput] var ViewToWorld : Real4x4;
  [AppBuiltInInput] var ViewportSize : Real2;
  
  [StageInput] var Uv : Real2;
  [StageInput] var PerspectivePosition : Real4;
  
  [Input] var DitherTexture : SampledImage2d;
  [Input] var EnvironmentBrdfLut : SampledImage2d;
  [Input] var Skybox : SampledImageCube;
  [Input] var SSRTexture : SampledImage2d;
  [Input] var VelocityBuffer : SampledImage2d;
  [Input] var Intensity : Real = 1.0;
  [Input] var MaxIntensity : Real = 50;
  
  [Input] var GeometryBuffer0 : SampledImage2d;
  [Input] var GeometryBuffer1 : SampledImage2d;
  
  [Input] var RenderDiffuse : Boolean = true;
  [Input] var RenderSpecular : Boolean = true;
  
  [Output] var Target0 : Real4;
  
  function Main()
  {
    // Get values from geometry buffers
    var geometrySample0 = this.GeometryBuffer0.Sample(this.Uv);
    var geometrySample1 = this.GeometryBuffer1.Sample(this.Uv);
    var velocity = this.VelocityBuffer.Sample(this.Uv).XY;
    var ssrSample = this.SSRTexture.Sample(this.Uv + velocity);
    
    var viewNormal = GeometryPass.GetNormal(geometrySample0);
    var viewPosition = Math.Multiply(this.PerspectiveToView, this.PerspectivePosition);
    var viewDirection = Math.Normalize(-viewPosition.XYZ / viewPosition.W);
    
    var iblInputs = ImageBasedLightingInputs();
    iblInputs.WorldNormal = Math.MultiplyNormal(this.ViewToWorld, viewNormal);
    iblInputs.WorldViewDirection = Math.MultiplyNormal(this.ViewToWorld, viewDirection);
    iblInputs.Albedo = GeometryPass.GetAlbedo(geometrySample1);
    iblInputs.Metallic = GeometryPass.GetMetallic(geometrySample1);
    iblInputs.Roughness = GeometryPass.GetRoughness(geometrySample0);
    iblInputs.Specular = GeometryPass.GetSpecular(geometrySample1);
    iblInputs.SSR = ssrSample;
    iblInputs.RenderDiffuse = this.RenderDiffuse;
    iblInputs.RenderSpecular = this.RenderSpecular;
    
    var color = ImageBasedLighting.Compute(iblInputs, &this.Skybox, &this.SSRTexture, &this.EnvironmentBrdfLut);
    
    // Remove color banding
    color = Utility.ApplyDither(color, &this.DitherTexture, this.Uv, this.ViewportSize);
    
    this.Target0 = Real4(Math.Min(color * this.Intensity, Real3(this.MaxIntensity)), 1.0);
  }
  
  [Static]
  function Compute(inputs : ImageBasedLightingInputs, skybox : ref SampledImageCube, ssr : ref SampledImage2d, brdfLut : ref SampledImage2d) : Real3
  {
    // Directions for sampling cubemap
    var diffuseDirection = inputs.WorldNormal;
    var specularDirection = Math.ReflectAcrossVector(inputs.WorldViewDirection, inputs.WorldNormal);
    
    // Cubemap details
    var textureSize = skybox.SampleSize(0).X;
    var maxLod = Math.Log2(textureSize);
    
    var envDiffuse = Real3.Zero;
    var diffuseColor = Real3.Zero;
    
    // Diffuse calculation
    if(inputs.SSR.W > 0.5)
    {
       envDiffuse = inputs.SSR.XYZ;
       diffuseColor = envDiffuse;
     }
    else
    {
      envDiffuse = skybox.SampleLod(diffuseDirection, maxLod).XYZ;
      diffuseColor = envDiffuse * inputs.Albedo;
    }
    // Sample lod for specular is based on roughness unless screen space derivitives
    // are large enough then we sample with that mip level to prevent aliasing
    var dx = ShaderIntrinsics.Ddx(specularDirection * textureSize);
    var dy = ShaderIntrinsics.Ddy(specularDirection * textureSize);
    var mipLevel = Math.Sqrt(Math.Max(Math.LengthSq(dx), Math.LengthSq(dy)));
    mipLevel = 0.5 * Math.Log2(mipLevel) - 1.0;
    var sampleLod = Math.Max(inputs.Roughness * maxLod, mipLevel);
    var envSpecular = Real3.Zero;
    
    if(inputs.SSR.W > 0.5)
      envSpecular = inputs.SSR.XYZ;
    else
      envSpecular = skybox.SampleLod(specularDirection, sampleLod).XYZ;
    
    // Specular calculation using split sum approximation
    var dotnv = Math.Saturate(Math.Dot(inputs.WorldNormal, inputs.WorldViewDirection));
    var brdfSpec = brdfLut.Sample(Real2(dotnv, inputs.Roughness)).XY;
    var metallicSpecular = envSpecular * (inputs.Albedo * brdfSpec.X + brdfSpec.YYY);
    var dialectricSpecular = envSpecular * (Real3(0.10) * brdfSpec.X + brdfSpec.YYY);
    
    // For debugging
    diffuseColor *= inputs.RenderDiffuse as Real;
    metallicSpecular *= inputs.RenderSpecular as Real;
    dialectricSpecular *= inputs.RenderSpecular as Real;
    
    // Linear combination between dialectric and metallic colors
    return Math.Lerp(diffuseColor + dialectricSpecular * inputs.Specular, metallicSpecular, inputs.Metallic);
  }
}
