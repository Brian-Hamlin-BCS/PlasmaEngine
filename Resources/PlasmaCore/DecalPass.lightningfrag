// MIT Licensed (see LICENSE.md).

// RenderPass fragments are intended to be constructed in script
// and passed directly to the AddRenderTaskRenderPass method.
// RenderPass fragment code is implicitely appended to the end
// of Materials in the compositing of the final shaders programs.
[Pixel][RenderPass]
struct DBufferPass
{
  [Input] var Color : Real4 = Real4(1.0, 0.0, 0.0, 1.0);
  
  [Input] var Albedo : Real3;
  [Input] var Alpha : Real;
  [Input] var Metallic : Real;
  [Input] var Roughness : Real;

  // Normal,  Roughness
  [Output] var Target0 : Real4;
  // Albedo, Metallic
  [Output] var Target1 : Real4;
  // SpecColor, AO
  [Output] var Target2 : Real4;
  // Specular, EmissivePower, BlendMode
  [Output] var Target3 : Real4;

  function Main()
  {
    this.Target0.W = this.Roughness;
    this.Target1.XYZ = this.Albedo.XYZ;
    this.Target1.W = this.Alpha;
  }
}

[Pixel][RenderPass]
struct DBufferApplyPass
{
  [Input] var Color : Real4 = Real4(1.0, 0.0, 0.0, 1.0);
  
  [Input] var Albedo : Real3;
  [Input] var Alpha : Real;
  [Input] var Metallic : Real;
  [Input] var Roughness : Real;

  [Output] var Target1 : Real4;

  function Main()
  {
    this.Target1 = Real4(1,0,0,1);
  }
}

[Pixel][PostProcess]
struct DecalMergeNormalRoughness
{
  
  [Input] var DBuffer0 : SampledImage2d;
  [Input] var GBuffer0 : SampledImage2d;
  [Input] var DBuffer1 : SampledImage2d;
  
  
  [FragmentInput][StageInput] var Uv : Real2;
  
  [Output] var Target1 : Real4;
      
  function Main()
  {
    var dbuffer = this.DBuffer0.Sample(this.Uv);
    var gbuffer = this.GBuffer0.Sample(this.Uv);
    var alpha = this.DBuffer1.Sample(this.Uv).W;
    
    var zSign = 1.0 - 2.0 * Math.Step(gbuffer.W, 0.0);
    
    this.Target1.XYZ = gbuffer.XYZ;
    // This is very strange, lerp should be 1.0 - alpha but this requires 1.0 + alpha.
    this.Target1.W = Math.Clamp((gbuffer.W * zSign )* (1.0 + alpha) + dbuffer.W * alpha , 0.001, 1);
  }
}


[Pixel][PostProcess]
struct DecalMergeAlbedo
{
  
  [Input] var DBuffer1 : SampledImage2d;
  [Input] var GBuffer1 : SampledImage2d;
  
  
  [FragmentInput][StageInput] var Uv : Real2;
  
  [Output] var Target1 : Real4;
      
  function Main()
  {
    var dbuffer = this.DBuffer1.Sample(this.Uv);
    var gbuffer = this.GBuffer1.Sample(this.Uv);
    
    this.Target1.XYZ = Math.Lerp(gbuffer.XYZ, dbuffer.XYZ, dbuffer.W);
    this.Target1.W = gbuffer.W;
  }
}
